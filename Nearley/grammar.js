// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

const moo = require("moo");

let lexer = moo.compile({
    WS: /[ \t]+/,
    comment: /\/\/.*?$/,
    number: /0|[1-9][0-9]*/,
    string: /"(?:\\["\\]|[^\n"\\])*"/,
    lparen: '(',
    rparen: ')',
    lbrace: '{',
    rbrace: '}',
    lbracket: '[',
    rbracket: ']',
    semicolon: ';',
    comma: ',',
    dot: '.',
    colon: ':',
    arrow: '->',
    plus: '+',
    minus: '-',
    multiply: '*',
    divide: '/',
    modulo: '%',
    power: '**',
    assign: '=',
    lt: '<',
    gt: '>',
    lte: '<=',
    gte: '>=',
    eq: '==',
    neq: '!=',
    kw: ['def', 'class', 'if', 'else', 'elif', 'while', 'for', 'in', 'try', 'except', 'finally', 'with', 'as', 'import', 'from', 'raise', 'return', 'assert', 'pass', 'break', 'continue', 'global', 'nonlocal', 'lambda', 'yield', 'del', 'async', 'await', 'and', 'or', 'not', 'is', 'None', 'True', 'False'],
    identifier: /[a-zA-Z_][a-zA-Z0-9_]*/,
    NL: { match: /\n/, lineBreaks: true },
});

function soft_keyword(kw) {
    return (d) => d[0].text === kw;
}
var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "file_input$ebnf$1", "symbols": ["statements"], "postprocess": id},
    {"name": "file_input$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "file_input", "symbols": ["file_input$ebnf$1", (lexer.has("EOF") ? {type: "EOF"} : EOF)]},
    {"name": "statements$ebnf$1", "symbols": ["statement"]},
    {"name": "statements$ebnf$1", "symbols": ["statements$ebnf$1", "statement"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "statements", "symbols": ["statements$ebnf$1"]},
    {"name": "statement", "symbols": ["simple_stmts"]},
    {"name": "simple_stmts$ebnf$1", "symbols": []},
    {"name": "simple_stmts$ebnf$1$subexpression$1", "symbols": [(lexer.has("semicolon") ? {type: "semicolon"} : semicolon), "simple_stmt"]},
    {"name": "simple_stmts$ebnf$1", "symbols": ["simple_stmts$ebnf$1", "simple_stmts$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "simple_stmts$ebnf$2", "symbols": [(lexer.has("semicolon") ? {type: "semicolon"} : semicolon)], "postprocess": id},
    {"name": "simple_stmts$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "simple_stmts", "symbols": ["simple_stmt", "simple_stmts$ebnf$1", "simple_stmts$ebnf$2", (lexer.has("NL") ? {type: "NL"} : NL)]},
    {"name": "simple_stmt", "symbols": ["assignment"]},
    {"name": "assignment$ebnf$1$subexpression$1", "symbols": ["star_targets", (lexer.has("assign") ? {type: "assign"} : assign)]},
    {"name": "assignment$ebnf$1", "symbols": ["assignment$ebnf$1$subexpression$1"]},
    {"name": "assignment$ebnf$1$subexpression$2", "symbols": ["star_targets", (lexer.has("assign") ? {type: "assign"} : assign)]},
    {"name": "assignment$ebnf$1", "symbols": ["assignment$ebnf$1", "assignment$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "assignment$subexpression$1", "symbols": ["yield_expr"]},
    {"name": "assignment$subexpression$1", "symbols": ["star_expressions"]},
    {"name": "assignment", "symbols": ["assignment$ebnf$1", "assignment$subexpression$1"]},
    {"name": "expressions$ebnf$1", "symbols": []},
    {"name": "expressions$ebnf$1$subexpression$1", "symbols": [(lexer.has("comma") ? {type: "comma"} : comma), "expression"]},
    {"name": "expressions$ebnf$1", "symbols": ["expressions$ebnf$1", "expressions$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "expressions$ebnf$2", "symbols": [(lexer.has("comma") ? {type: "comma"} : comma)], "postprocess": id},
    {"name": "expressions$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "expressions", "symbols": ["expression", "expressions$ebnf$1", "expressions$ebnf$2"]},
    {"name": "expression$ebnf$1$subexpression$1", "symbols": [{"literal":"if"}, "disjunction", {"literal":"else"}, "expression"]},
    {"name": "expression$ebnf$1", "symbols": ["expression$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "expression$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "expression", "symbols": ["disjunction", "expression$ebnf$1"]},
    {"name": "yield_expr$subexpression$1", "symbols": [{"literal":"from"}, "expression"]},
    {"name": "yield_expr$subexpression$1$ebnf$1", "symbols": ["star_expressions"], "postprocess": id},
    {"name": "yield_expr$subexpression$1$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "yield_expr$subexpression$1", "symbols": ["yield_expr$subexpression$1$ebnf$1"]},
    {"name": "yield_expr", "symbols": [{"literal":"yield"}, "yield_expr$subexpression$1"]},
    {"name": "star_expressions$ebnf$1", "symbols": []},
    {"name": "star_expressions$ebnf$1$subexpression$1", "symbols": [(lexer.has("comma") ? {type: "comma"} : comma), "star_expression"]},
    {"name": "star_expressions$ebnf$1", "symbols": ["star_expressions$ebnf$1", "star_expressions$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "star_expressions$ebnf$2", "symbols": [(lexer.has("comma") ? {type: "comma"} : comma)], "postprocess": id},
    {"name": "star_expressions$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "star_expressions", "symbols": ["star_expression", "star_expressions$ebnf$1", "star_expressions$ebnf$2"]},
    {"name": "star_expression", "symbols": [{"literal":"*"}, "bitwise_or"]},
    {"name": "star_expression", "symbols": ["expression"]},
    {"name": "disjunction$ebnf$1", "symbols": []},
    {"name": "disjunction$ebnf$1$subexpression$1", "symbols": [{"literal":"or"}, "conjunction"]},
    {"name": "disjunction$ebnf$1", "symbols": ["disjunction$ebnf$1", "disjunction$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "disjunction", "symbols": ["conjunction", "disjunction$ebnf$1"]},
    {"name": "conjunction$ebnf$1", "symbols": []},
    {"name": "conjunction$ebnf$1$subexpression$1", "symbols": [{"literal":"and"}, "inversion"]},
    {"name": "conjunction$ebnf$1", "symbols": ["conjunction$ebnf$1", "conjunction$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "conjunction", "symbols": ["inversion", "conjunction$ebnf$1"]},
    {"name": "inversion", "symbols": [{"literal":"not"}, "inversion"]},
    {"name": "inversion", "symbols": ["comparison"]},
    {"name": "comparison", "symbols": ["bitwise_or"]},
    {"name": "bitwise_or", "symbols": ["bitwise_or", {"literal":"|"}, "bitwise_xor"]},
    {"name": "bitwise_or", "symbols": ["bitwise_xor"]},
    {"name": "bitwise_xor", "symbols": ["bitwise_xor", {"literal":"^"}, "bitwise_and"]},
    {"name": "bitwise_xor", "symbols": ["bitwise_and"]},
    {"name": "bitwise_and", "symbols": ["bitwise_and", {"literal":"&"}, "shift_expr"]},
    {"name": "bitwise_and", "symbols": ["shift_expr"]},
    {"name": "shift_expr$subexpression$1", "symbols": [{"literal":"<<"}]},
    {"name": "shift_expr$subexpression$1", "symbols": [{"literal":">>"}]},
    {"name": "shift_expr", "symbols": ["shift_expr", "shift_expr$subexpression$1", "sum"]},
    {"name": "shift_expr", "symbols": ["sum"]},
    {"name": "sum$subexpression$1", "symbols": [(lexer.has("plus") ? {type: "plus"} : plus)]},
    {"name": "sum$subexpression$1", "symbols": [(lexer.has("minus") ? {type: "minus"} : minus)]},
    {"name": "sum", "symbols": ["sum", "sum$subexpression$1", "term"]},
    {"name": "sum", "symbols": ["term"]},
    {"name": "term$subexpression$1", "symbols": [{"literal":"*"}]},
    {"name": "term$subexpression$1", "symbols": [{"literal":"/"}]},
    {"name": "term$subexpression$1", "symbols": [{"literal":"//"}]},
    {"name": "term$subexpression$1", "symbols": [{"literal":"%"}]},
    {"name": "term$subexpression$1", "symbols": [{"literal":"@"}]},
    {"name": "term", "symbols": ["term", "term$subexpression$1", "factor"]},
    {"name": "term", "symbols": ["factor"]},
    {"name": "factor", "symbols": [(lexer.has("plus") ? {type: "plus"} : plus), "factor"]},
    {"name": "factor", "symbols": [(lexer.has("minus") ? {type: "minus"} : minus), "factor"]},
    {"name": "factor", "symbols": [{"literal":"~"}, "factor"]},
    {"name": "factor", "symbols": ["power"]},
    {"name": "power$ebnf$1$subexpression$1", "symbols": [{"literal":"**"}, "factor"]},
    {"name": "power$ebnf$1", "symbols": ["power$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "power$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "power", "symbols": ["await_primary", "power$ebnf$1"]},
    {"name": "await_primary", "symbols": [{"literal":"await"}, "primary"]},
    {"name": "await_primary", "symbols": ["primary"]},
    {"name": "primary", "symbols": ["atom"]},
    {"name": "atom", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier)]},
    {"name": "atom", "symbols": [(lexer.has("number") ? {type: "number"} : number)]},
    {"name": "star_targets$ebnf$1", "symbols": []},
    {"name": "star_targets$ebnf$1$subexpression$1", "symbols": [(lexer.has("comma") ? {type: "comma"} : comma), "star_target"]},
    {"name": "star_targets$ebnf$1", "symbols": ["star_targets$ebnf$1", "star_targets$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "star_targets$ebnf$2", "symbols": [(lexer.has("comma") ? {type: "comma"} : comma)], "postprocess": id},
    {"name": "star_targets$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "star_targets", "symbols": ["star_target", "star_targets$ebnf$1", "star_targets$ebnf$2"]},
    {"name": "star_target$subexpression$1", "symbols": ["star_target"]},
    {"name": "star_target", "symbols": [(lexer.has("multiply") ? {type: "multiply"} : multiply), "star_target$subexpression$1"]},
    {"name": "star_target", "symbols": ["target_with_star_atom"]},
    {"name": "target_with_star_atom", "symbols": ["star_atom"]},
    {"name": "star_atom", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier)]}
]
  , ParserStart: "file_input"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
